/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

var Stream = (function () {
    function Stream(options, infiniteReset) {
        this.options = options;
        this.streamActive = false;
        this.data = [];
        this.interval = this.options.interval || 1000;
        this.batchSize = this.options.batchSize || 1;
        this.batchesLeft = -2;
        this.runStream = this.runStream.bind(this);
        this.infiniteReset = infiniteReset;
        if (options.repeat !== undefined) {
            if (typeof options.repeat === 'boolean') {
                this.batchesLeft = options.repeat ? -1 : -2;
            }
            else if (typeof options.repeat === 'number') {
                this.batchesLeft = options.repeat + 1;
            }
            else if (typeof options.repeat === 'function') {
                this.continueHandler = options.repeat;
            }
        }
    }
    Stream.prototype.consume = function () {
        var _this = this;
        var cutCount = this.batchSize;
        if (this.data.length < this.batchSize) {
            cutCount = this.data.length;
        }
        var consumed = this.data.splice(0, cutCount);
        if ((this.batchesLeft > 0 || this.batchesLeft === -1) && consumed.length > 0) {
            this.data = this.data.concat(consumed.map(function (dataPoint) { return _this.infiniteReset(dataPoint); }));
            if (consumed.length < this.batchSize) {
                while (consumed.length < this.batchSize) {
                    var nextPoint = this.data.splice(0, 1)[0];
                    this.data = this.data.concat(this.infiniteReset(nextPoint));
                    consumed.push(nextPoint);
                }
            }
        }
        return consumed;
    };
    Stream.prototype.checkStreamContinue = function () {
        var continueStream = (this.batchesLeft > 0 ||
            this.batchesLeft === -1 ||
            (this.batchesLeft === -2 && this.data.length > 0))
            ? true : false;
        if (this.continueHandler) {
            continueStream = this.continueHandler() === true;
        }
        return continueStream;
    };
    Stream.prototype.runStream = function () {
        var continueStream = this.checkStreamContinue();
        if (this.data && this.data.length > 0 && continueStream) {
            if (this.streamHandler) {
                var curData = this.consume();
                this.streamHandler(curData);
            }
            setTimeout(this.runStream, this.interval);
        }
        else {
            this.streamActive = false;
        }
        if (this.batchesLeft > 0)
            this.batchesLeft--;
    };
    Stream.prototype.activateStream = function () {
        if (!this.streamActive) {
            this.streamActive = true;
            this.runStream();
        }
    };
    Stream.prototype.push = function (newData) {
        if (Array.isArray(newData)) {
            this.data = this.data.concat(newData);
        }
        else {
            this.data.push(newData);
        }
        this.activateStream();
    };
    Stream.prototype.map = function (handler) {
        this.outputStream = new Stream(__assign(__assign({}, this.options), { repeat: false }), this.infiniteReset);
        this.mapHandler = handler;
        this.streamHandler = this._map;
        this.activateStream();
        return this.outputStream;
    };
    Stream.prototype._map = function (data) {
        if (this.mapHandler && this.outputStream) {
            var mapped = data.map(this.mapHandler);
            this.outputStream.push(mapped);
        }
    };
    Stream.prototype.forEach = function (handler) {
        this.forEachHandler = handler;
        this.streamHandler = this._forEach;
        this.activateStream();
    };
    Stream.prototype._forEach = function (data) {
        if (this.forEachHandler)
            data.forEach(this.forEachHandler);
    };
    return Stream;
}());

var DataHost = (function () {
    function DataHost(infiniteResetHandler, streamOptions) {
        this.data = [];
        this.derivativeDataHosts = [];
        this.promisesToResolve = [];
        this.streamsToPush = [];
        this.infiniteReset = this.infiniteReset.bind(this);
        this.infiniteResetHandler = infiniteResetHandler;
        var opts = {
            interval: streamOptions.interval,
            batchSize: streamOptions.batchSize,
            repeat: streamOptions.repeat !== undefined ? streamOptions.repeat : false
        };
        this.streamOptions = Object.freeze(opts);
    }
    DataHost.prototype.toStream = function () {
        var stream = new Stream(this.streamOptions, this.infiniteReset);
        if (this.frozenData) {
            stream.push(this.frozenData);
        }
        else {
            this.streamsToPush.push(stream);
        }
        return stream;
    };
    DataHost.prototype.toPromise = function () {
        var _this = this;
        var pr;
        if (this.frozenData) {
            pr = Promise.resolve(this.frozenData);
        }
        else {
            pr = new Promise(function (resolve) { _this.promisesToResolve.push(resolve); });
        }
        return pr;
    };
    DataHost.prototype.infiniteReset = function (data) {
        return this.infiniteResetHandler(data, this.frozenData ? this.frozenData : []);
    };
    DataHost.prototype.push = function (data) {
        var e_1, _a;
        if (!this.frozenData) {
            if (Array.isArray(data)) {
                try {
                    for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                        var d = data_1_1.value;
                        this.data.push(d);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else {
                this.data.push(data);
            }
        }
    };
    DataHost.prototype.setData = function (newData) {
        this.data = newData;
    };
    DataHost.prototype.freeze = function () {
        var _this = this;
        if (!this.frozenData) {
            this.frozenData = this.data;
            setTimeout(function () {
                _this.promisesToResolve.forEach(function (p) { return p(_this.frozenData); });
                _this.promisesToResolve = [];
            }, 0);
            setTimeout(function () {
                _this.streamsToPush.forEach(function (s) { return s.push(_this.frozenData || []); });
                _this.streamsToPush = [];
            }, 0);
            setTimeout(function () {
                _this.handleDerivativeDataHosts();
            }, 0);
            this.data = [];
        }
    };
    DataHost.prototype.getPointCount = function () {
        return this.frozenData ? this.frozenData.length : 0;
    };
    DataHost.prototype.handleDerivativeDataHosts = function () {
        var _this = this;
        if (this.frozenData && this.derivativeDataHosts.length > 0) {
            this.derivativeDataHosts.forEach(function (host) {
                if (_this.frozenData) {
                    host.setData(_this.frozenData);
                }
                host.freeze();
            });
            this.derivativeDataHosts = [];
        }
    };
    DataHost.prototype.setStreamInterval = function (interval) {
        var dataHost = new DataHost(this.infiniteResetHandler, __assign(__assign({}, this.streamOptions), { interval: interval }));
        this.derivativeDataHosts.push(dataHost);
        this.handleDerivativeDataHosts();
        return dataHost;
    };
    DataHost.prototype.setStreamBatchSize = function (batchSize) {
        var dataHost = new DataHost(this.infiniteResetHandler, __assign(__assign({}, this.streamOptions), { batchSize: batchSize }));
        this.derivativeDataHosts.push(dataHost);
        this.handleDerivativeDataHosts();
        return dataHost;
    };
    DataHost.prototype.setStreamRepeat = function (repeat) {
        var dataHost = new DataHost(this.infiniteResetHandler, __assign(__assign({}, this.streamOptions), { repeat: repeat }));
        this.derivativeDataHosts.push(dataHost);
        this.handleDerivativeDataHosts();
        return dataHost;
    };
    return DataHost;
}());

var perfNow;
if (typeof window !== 'undefined' && window.performance && window.performance.now) {
    perfNow = window.performance.now.bind(window.performance);
}
else {
    try {
        if (typeof require !== 'undefined') {
            perfNow = require('perf_hooks').performance.now;
        }
        else {
            throw new Error();
        }
    }
    catch (e) {
        throw new Error('Failed to detect "performance.now" API');
    }
}
var DataGenerator = (function () {
    function DataGenerator(args) {
        this.options = args;
    }
    DataGenerator.prototype.generate = function () {
        var dataHost = new DataHost(this.infiniteReset, {
            interval: 500,
            batchSize: 10,
            repeat: false
        });
        var points = this.getPointCount();
        var nextChunk = this.generateChunks.bind(this, 0, points, dataHost);
        setTimeout(nextChunk, 0);
        return dataHost;
    };
    DataGenerator.prototype.generateChunks = function (baseIndex, total, dataHost) {
        var startTime = perfNow();
        var points = [];
        for (var i = 0; perfNow() - startTime < 15 && baseIndex < total; i++) {
            var point = this.generateDataPoint(baseIndex);
            baseIndex++;
            points.push(point);
        }
        dataHost.push(points);
        if (baseIndex < total) {
            var nextChunk = this.generateChunks.bind(this, baseIndex, total, dataHost);
            setTimeout(nextChunk, 0);
        }
        else {
            dataHost.freeze();
        }
    };
    return DataGenerator;
}());

function createProgressiveRandomGenerator() {
    return new ProgressiveRandomGenerator({
        numberOfPoints: 1000,
        offsetStep: 10,
        offsetDeltaMax: 0.3,
        offsetDeltaMin: 0.1,
        dataMax: 0.5
    });
}
var ProgressiveRandomGenerator = (function (_super) {
    __extends(ProgressiveRandomGenerator, _super);
    function ProgressiveRandomGenerator(args) {
        var _this = _super.call(this, args) || this;
        _this.offset = 0.5;
        var opts = {
            numberOfPoints: args.numberOfPoints,
            offsetStep: args.offsetStep === 0 ? 0 : args.offsetStep,
            offsetDeltaMax: Math.min(args.offsetDeltaMax, 1),
            offsetDeltaMin: Math.max(args.offsetDeltaMin === 0 ? 0 : args.offsetDeltaMin, 0),
            dataMax: Math.min(args.dataMax, 1)
        };
        _this.options = Object.freeze(opts);
        return _this;
    }
    ProgressiveRandomGenerator.prototype.setNumberOfPoints = function (numberOfPoints) {
        return new ProgressiveRandomGenerator(__assign(__assign({}, this.options), { numberOfPoints: numberOfPoints }));
    };
    ProgressiveRandomGenerator.prototype.setOffsetStep = function (offsetStep) {
        return new ProgressiveRandomGenerator(__assign(__assign({}, this.options), { offsetStep: offsetStep }));
    };
    ProgressiveRandomGenerator.prototype.setOffsetDeltaMax = function (offsetDeltaMax) {
        return new ProgressiveRandomGenerator(__assign(__assign({}, this.options), { offsetDeltaMax: offsetDeltaMax }));
    };
    ProgressiveRandomGenerator.prototype.setOffsetDeltaMin = function (offsetDeltaMin) {
        return new ProgressiveRandomGenerator(__assign(__assign({}, this.options), { offsetDeltaMin: offsetDeltaMin }));
    };
    ProgressiveRandomGenerator.prototype.setDataMax = function (dataMax) {
        return new ProgressiveRandomGenerator(__assign(__assign({}, this.options), { dataMax: dataMax }));
    };
    ProgressiveRandomGenerator.prototype.getPointCount = function () {
        return this.options.numberOfPoints;
    };
    ProgressiveRandomGenerator.prototype.generateDataPoint = function (i) {
        if (i % this.options.offsetStep === 0 || i === 0) {
            var newOffset = Math.random() * (this.options.offsetDeltaMax - this.options.offsetDeltaMin) + this.options.offsetDeltaMin;
            this.offset = Math.random() > 0.5 ? this.offset + newOffset : this.offset - newOffset;
        }
        if (this.offset + this.options.dataMax > 1) {
            this.offset = 1 - this.options.dataMax;
        }
        else if (this.offset < 0) {
            this.offset = 0;
        }
        return {
            x: i,
            y: this.offset + Math.random() * this.options.dataMax
        };
    };
    ProgressiveRandomGenerator.prototype.infiniteReset = function (dataToReset, data) {
        return { x: dataToReset.x + data.length, y: dataToReset.y };
    };
    return ProgressiveRandomGenerator;
}(DataGenerator));

function createProgressiveTraceGenerator() {
    return new ProgressiveTraceGenerator({
        numberOfPoints: 1000
    });
}
var ProgressiveTraceGenerator = (function (_super) {
    __extends(ProgressiveTraceGenerator, _super);
    function ProgressiveTraceGenerator(args) {
        var _this = _super.call(this, args) || this;
        _this.previousPoint = { x: 0, y: 0 };
        var opts = {
            numberOfPoints: args.numberOfPoints
        };
        _this.options = Object.freeze(opts);
        return _this;
    }
    ProgressiveTraceGenerator.prototype.setNumberOfPoints = function (numberOfPoints) {
        return new ProgressiveTraceGenerator(__assign(__assign({}, this.options), { numberOfPoints: numberOfPoints }));
    };
    ProgressiveTraceGenerator.prototype.getPointCount = function () {
        return this.options.numberOfPoints;
    };
    ProgressiveTraceGenerator.prototype.generateDataPoint = function (i) {
        var point = {
            x: i,
            y: this.previousPoint.y + (Math.random() - 0.5) * 2
        };
        this.previousPoint = point;
        return point;
    };
    ProgressiveTraceGenerator.prototype.infiniteReset = function (dataToReset, data) {
        return { x: dataToReset.x + data.length, y: dataToReset.y };
    };
    return ProgressiveTraceGenerator;
}(DataGenerator));

function createProgressiveFunctionGenerator() {
    return new ProgressiveFunctionGenerator({
        samplingFunction: function (x) { return x * x; },
        start: 0,
        end: 100,
        step: 1
    });
}
var ProgressiveFunctionGenerator = (function (_super) {
    __extends(ProgressiveFunctionGenerator, _super);
    function ProgressiveFunctionGenerator(args) {
        var _this = _super.call(this, args) || this;
        _this.x = _this.options.start;
        var opts = {
            samplingFunction: args.samplingFunction,
            start: args.start,
            end: args.end,
            step: args.step
        };
        _this.options = Object.freeze(opts);
        _this.numberOfPoints = Math.ceil(Math.abs(opts.end - opts.start) / opts.step);
        return _this;
    }
    ProgressiveFunctionGenerator.prototype.setSamplingFunction = function (handler) {
        return new ProgressiveFunctionGenerator(__assign(__assign({}, this.options), { samplingFunction: handler }));
    };
    ProgressiveFunctionGenerator.prototype.setStart = function (start) {
        return new ProgressiveFunctionGenerator(__assign(__assign({}, this.options), { start: start }));
    };
    ProgressiveFunctionGenerator.prototype.setEnd = function (end) {
        return new ProgressiveFunctionGenerator(__assign(__assign({}, this.options), { end: end }));
    };
    ProgressiveFunctionGenerator.prototype.setStep = function (step) {
        return new ProgressiveFunctionGenerator(__assign(__assign({}, this.options), { step: step }));
    };
    ProgressiveFunctionGenerator.prototype.getPointCount = function () {
        return this.numberOfPoints;
    };
    ProgressiveFunctionGenerator.prototype.generateDataPoint = function () {
        var point = {
            x: this.x,
            y: this.options.samplingFunction(this.x)
        };
        this.x = this.x + this.options.step;
        return point;
    };
    ProgressiveFunctionGenerator.prototype.infiniteReset = function (dataToReset, data) {
        return { x: dataToReset.x + data.length * (data[data.length - 1].x - data[data.length - 2].x), y: dataToReset.y };
    };
    return ProgressiveFunctionGenerator;
}(DataGenerator));

function createTraceGenerator() {
    return new TraceGenerator({
        numberOfPoints: 1000
    });
}
var TraceGenerator = (function (_super) {
    __extends(TraceGenerator, _super);
    function TraceGenerator(args) {
        var _this = _super.call(this, args) || this;
        _this.previous = { x: 0, y: 0 };
        var opts = {
            numberOfPoints: args.numberOfPoints
        };
        _this.options = Object.freeze(opts);
        return _this;
    }
    TraceGenerator.prototype.setNumberOfPoints = function (numberOfPoints) {
        return new TraceGenerator(__assign(__assign({}, this.options), { numberOfPoints: numberOfPoints }));
    };
    TraceGenerator.prototype.getPointCount = function () {
        return this.options.numberOfPoints;
    };
    TraceGenerator.prototype.generateDataPoint = function () {
        var point = {
            x: this.previous.x + (Math.random() - 0.5) * 2,
            y: this.previous.y + (Math.random() - 0.5) * 2
        };
        this.previous = point;
        return point;
    };
    TraceGenerator.prototype.infiniteReset = function (dataToReset, data) {
        return { x: dataToReset.x + data[data.length - 1].x, y: dataToReset.y + data[data.length - 1].y };
    };
    return TraceGenerator;
}(DataGenerator));

function createOHLCGenerator() {
    return new OHLCGenerator({
        numberOfPoints: 1000,
        startTimestamp: 0,
        dataFreq: 1,
        start: 100,
        volatility: 0.1
    });
}
var OHLCGenerator = (function (_super) {
    __extends(OHLCGenerator, _super);
    function OHLCGenerator(args) {
        var _this = _super.call(this, args) || this;
        _this.prevPoint = [_this.options.startTimestamp, _this.options.start, _this.options.start, _this.options.start, _this.options.start];
        return _this;
    }
    OHLCGenerator.prototype.setNumberOfPoints = function (numberOfPoints) {
        return new OHLCGenerator(__assign(__assign({}, this.options), { numberOfPoints: numberOfPoints }));
    };
    OHLCGenerator.prototype.setStartTimestamp = function (startTimestamp) {
        return new OHLCGenerator(__assign(__assign({}, this.options), { startTimestamp: startTimestamp }));
    };
    OHLCGenerator.prototype.setDataFrequency = function (dataFreq) {
        return new OHLCGenerator(__assign(__assign({}, this.options), { dataFreq: dataFreq }));
    };
    OHLCGenerator.prototype.setStart = function (start) {
        return new OHLCGenerator(__assign(__assign({}, this.options), { start: start }));
    };
    OHLCGenerator.prototype.setVolatility = function (volatility) {
        return new OHLCGenerator(__assign(__assign({}, this.options), { volatility: volatility }));
    };
    OHLCGenerator.prototype.getPointCount = function () {
        return this.options.numberOfPoints;
    };
    OHLCGenerator.prototype.generateDataPoint = function (i) {
        var _this = this;
        var dataPoint = [0, 0, 0, 0, 0];
        var timeStamp = (this.options.startTimestamp + this.options.dataFreq * i);
        var dir = Math.random() > 0.5 ? 1 : -1;
        var newPoints = Array.from(Array(4)).map(function (v) {
            var change = Math.random() * _this.options.volatility * dir;
            if (_this.prevPoint[4] + change < 0) {
                change = change * -1;
            }
            return _this.prevPoint[4] + change;
        }).sort(function (a, b) { return a - b; });
        if (dir === -1) {
            newPoints = [newPoints[0], newPoints[2], newPoints[1], newPoints[3]];
        }
        dataPoint = [timeStamp, newPoints[1], newPoints[3], newPoints[0], newPoints[2]];
        this.prevPoint = dataPoint;
        return dataPoint;
    };
    OHLCGenerator.prototype.infiniteReset = function (dataToReset, data) {
        var newPoint = [
            dataToReset[0] + data.length * (data[data.length - 1][0] - data[data.length - 2][0]),
            dataToReset[1],
            dataToReset[2],
            dataToReset[3],
            dataToReset[4]
        ];
        return newPoint;
    };
    return OHLCGenerator;
}(DataGenerator));

function createDeltaFunctionGenerator() {
    return new DeltaFunctionGenerator({
        numberOfPoints: 1000,
        minGap: 1,
        maxGap: -1,
        minAmplitude: 0.1,
        maxAmplitude: 1,
        probability: 0.02
    });
}
var DeltaFunctionGenerator = (function (_super) {
    __extends(DeltaFunctionGenerator, _super);
    function DeltaFunctionGenerator(args) {
        var _this = _super.call(this, args) || this;
        _this.lastSpike = 0;
        var opts = {
            numberOfPoints: args.numberOfPoints,
            minGap: args.minGap,
            maxGap: args.maxGap,
            minAmplitude: args.minAmplitude,
            maxAmplitude: args.maxAmplitude,
            probability: args.probability
        };
        _this.options = Object.freeze(opts);
        return _this;
    }
    DeltaFunctionGenerator.prototype.setNumberOfPoints = function (numberOfPoints) {
        return new DeltaFunctionGenerator(__assign(__assign({}, this.options), { numberOfPoints: numberOfPoints }));
    };
    DeltaFunctionGenerator.prototype.setMinGap = function (minGap) {
        return new DeltaFunctionGenerator(__assign(__assign({}, this.options), { minGap: minGap }));
    };
    DeltaFunctionGenerator.prototype.setMaxGap = function (maxGap) {
        return new DeltaFunctionGenerator(__assign(__assign({}, this.options), { maxGap: maxGap }));
    };
    DeltaFunctionGenerator.prototype.setMinAmplitude = function (minAmplitude) {
        return new DeltaFunctionGenerator(__assign(__assign({}, this.options), { minAmplitude: minAmplitude }));
    };
    DeltaFunctionGenerator.prototype.setMaxAmplitude = function (maxAmplitude) {
        return new DeltaFunctionGenerator(__assign(__assign({}, this.options), { maxAmplitude: maxAmplitude }));
    };
    DeltaFunctionGenerator.prototype.setProbability = function (probability) {
        return new DeltaFunctionGenerator(__assign(__assign({}, this.options), { probability: probability }));
    };
    DeltaFunctionGenerator.prototype.getPointCount = function () {
        return this.options.numberOfPoints;
    };
    DeltaFunctionGenerator.prototype.generateDataPoint = function (i) {
        var sinceLast = i - this.lastSpike;
        var value = { x: i, y: 0 };
        if (sinceLast > this.options.minGap || this.options.minGap === -1) {
            if (sinceLast < this.options.maxGap || this.options.maxGap === -1) {
                var doSpike = Math.random() > (1 - this.options.probability);
                if (doSpike) {
                    value.y = Math.random() * (this.options.maxAmplitude - this.options.minAmplitude) + this.options.minAmplitude;
                    this.lastSpike = i;
                }
            }
            else if (sinceLast >= this.options.maxGap) {
                value.y = Math.random() * (this.options.maxAmplitude - this.options.minAmplitude) + this.options.minAmplitude;
                this.lastSpike = i;
            }
        }
        return value;
    };
    DeltaFunctionGenerator.prototype.infiniteReset = function (dataToReset, data) {
        return { x: dataToReset.x + data.length, y: dataToReset.y };
    };
    return DeltaFunctionGenerator;
}(DataGenerator));

function createWhiteNoiseGenerator() {
    return new WhiteNoiseGenerator({
        numberOfPoints: 1000
    });
}
var WhiteNoiseGenerator = (function (_super) {
    __extends(WhiteNoiseGenerator, _super);
    function WhiteNoiseGenerator(args) {
        var _this = _super.call(this, args) || this;
        var opts = {
            numberOfPoints: args.numberOfPoints
        };
        _this.options = Object.freeze(opts);
        return _this;
    }
    WhiteNoiseGenerator.prototype.setNumberOfPoints = function (numberOfPoints) {
        return new WhiteNoiseGenerator(this.options ? __assign(__assign({}, this.options), { numberOfPoints: numberOfPoints }) : { numberOfPoints: numberOfPoints });
    };
    WhiteNoiseGenerator.prototype.getPointCount = function () {
        return this.options.numberOfPoints;
    };
    WhiteNoiseGenerator.prototype.generateDataPoint = function (i) {
        var point = {
            x: i,
            y: (Math.random() - 0.5) * 2
        };
        return point;
    };
    WhiteNoiseGenerator.prototype.infiniteReset = function (dataToReset, data) {
        return { x: dataToReset.x + data[data.length - 1].x, y: dataToReset.y + data[data.length - 1].y };
    };
    return WhiteNoiseGenerator;
}(DataGenerator));

function createSampledDataGenerator() {
    return new SampledDataGenerator({
        inputData: [],
        samplingFrequency: 50,
        step: 0
    });
}
var SampledDataGenerator = (function (_super) {
    __extends(SampledDataGenerator, _super);
    function SampledDataGenerator(args) {
        var _this = _super.call(this, args) || this;
        _this.interval = 1 / (_this.options.samplingFrequency || 10);
        var opts = {
            inputData: args.inputData,
            samplingFrequency: args.samplingFrequency,
            step: args.step
        };
        _this.options = Object.freeze(opts);
        return _this;
    }
    SampledDataGenerator.prototype.setInputData = function (inputData) {
        return new SampledDataGenerator(__assign(__assign({}, this.options), { inputData: inputData }));
    };
    SampledDataGenerator.prototype.setSamplingFrequency = function (samplingFrequency) {
        return new SampledDataGenerator(__assign(__assign({}, this.options), { samplingFrequency: samplingFrequency }));
    };
    SampledDataGenerator.prototype.setStep = function (step) {
        return new SampledDataGenerator(__assign(__assign({}, this.options), { step: step }));
    };
    SampledDataGenerator.prototype.getPointCount = function () {
        return this.options.inputData.length;
    };
    SampledDataGenerator.prototype.generateDataPoint = function (i) {
        var point = {
            timestamp: i * this.interval + i * this.options.step,
            data: this.options.inputData[i]
        };
        return point;
    };
    SampledDataGenerator.prototype.infiniteReset = function (dataToReset, data) {
        return { timestamp: dataToReset.timestamp + data[data.length - 1].timestamp, data: dataToReset.data };
    };
    return SampledDataGenerator;
}(DataGenerator));

function createParametricFunctionGenerator() {
    return new ParametricFunctionGenerator({
        xFunction: function (t) { return 3 * Math.cos(3 * t); },
        yFunction: function (t) { return 3 * Math.sin(4 * t); },
        start: 0,
        end: 1000,
        step: 0.5
    });
}
var ParametricFunctionGenerator = (function (_super) {
    __extends(ParametricFunctionGenerator, _super);
    function ParametricFunctionGenerator(args) {
        var _this = _super.call(this, args) || this;
        _this.t = _this.options.start;
        var opts = {
            xFunction: args.xFunction,
            yFunction: args.yFunction,
            start: args.start,
            end: args.end,
            step: args.step
        };
        _this.options = Object.freeze(opts);
        _this.numberOfPoints = Math.ceil(Math.abs(opts.end - opts.start) / opts.step);
        return _this;
    }
    ParametricFunctionGenerator.prototype.setXFunction = function (handler) {
        return new ParametricFunctionGenerator(__assign(__assign({}, this.options), { xFunction: handler }));
    };
    ParametricFunctionGenerator.prototype.setYFunction = function (handler) {
        return new ParametricFunctionGenerator(__assign(__assign({}, this.options), { yFunction: handler }));
    };
    ParametricFunctionGenerator.prototype.setStart = function (start) {
        return new ParametricFunctionGenerator(__assign(__assign({}, this.options), { start: start }));
    };
    ParametricFunctionGenerator.prototype.setEnd = function (end) {
        return new ParametricFunctionGenerator(__assign(__assign({}, this.options), { end: end }));
    };
    ParametricFunctionGenerator.prototype.setStep = function (step) {
        return new ParametricFunctionGenerator(__assign(__assign({}, this.options), { step: step }));
    };
    ParametricFunctionGenerator.prototype.getPointCount = function () {
        return this.numberOfPoints;
    };
    ParametricFunctionGenerator.prototype.generateDataPoint = function () {
        var point = {
            x: this.options.xFunction(this.t),
            y: this.options.yFunction(this.t)
        };
        this.t = this.t + this.options.step;
        return point;
    };
    ParametricFunctionGenerator.prototype.infiniteReset = function (dataToReset, data) {
        return { x: dataToReset.x, y: dataToReset.y };
    };
    return ParametricFunctionGenerator;
}(DataGenerator));

var defaultOptions = {
    numberOfSamples: 1000,
    sampleSize: 10,
    variation: 10.0,
    frequencyStability: 1.0,
    narrowFactor1: 8.0,
    narrowFactor2: 24.0
};
function createSpectrumDataGenerator() {
    return new SpectrumDataGenerator(defaultOptions);
}
var SpectrumDataGenerator = (function (_super) {
    __extends(SpectrumDataGenerator, _super);
    function SpectrumDataGenerator(args) {
        var _this = _super.call(this, args) || this;
        var opts = {
            sampleSize: args.sampleSize !== undefined ? args.sampleSize : defaultOptions.sampleSize,
            numberOfSamples: args.numberOfSamples !== undefined ? args.numberOfSamples : defaultOptions.numberOfSamples,
            variation: args.variation !== undefined ? args.variation : defaultOptions.variation,
            frequencyStability: args.frequencyStability !== undefined ? args.frequencyStability : defaultOptions.frequencyStability,
            narrowFactor1: args.narrowFactor1 !== undefined ? args.narrowFactor1 : defaultOptions.narrowFactor1,
            narrowFactor2: args.narrowFactor2 !== undefined ? args.narrowFactor2 : defaultOptions.narrowFactor2
        };
        _this.options = Object.freeze(opts);
        return _this;
    }
    SpectrumDataGenerator.prototype.setNumberOfSamples = function (numberOfSamples) {
        return new SpectrumDataGenerator(__assign(__assign({}, this.options), { numberOfSamples: numberOfSamples }));
    };
    SpectrumDataGenerator.prototype.setSampleSize = function (sampleSize) {
        return new SpectrumDataGenerator(__assign(__assign({}, this.options), { sampleSize: sampleSize }));
    };
    SpectrumDataGenerator.prototype.setVariation = function (variation) {
        return new SpectrumDataGenerator(__assign(__assign({}, this.options), { variation: variation }));
    };
    SpectrumDataGenerator.prototype.setFrequencyStability = function (frequencyStability) {
        return new SpectrumDataGenerator(__assign(__assign({}, this.options), { frequencyStability: frequencyStability }));
    };
    SpectrumDataGenerator.prototype.setNarrowFactor1 = function (narrowFactor1) {
        return new SpectrumDataGenerator(__assign(__assign({}, this.options), { narrowFactor1: narrowFactor1 }));
    };
    SpectrumDataGenerator.prototype.setNarrowFactor2 = function (narrowFactor2) {
        return new SpectrumDataGenerator(__assign(__assign({}, this.options), { narrowFactor2: narrowFactor2 }));
    };
    SpectrumDataGenerator.prototype.getPointCount = function () {
        return this.options.numberOfSamples;
    };
    SpectrumDataGenerator.prototype.generateDataPoint = function (iPoint) {
        var m_dInitialValue = 10.0;
        var m_dMax = 100;
        var m_dMin = 0;
        var m_dVariation = this.options.variation;
        var m_iRowLength = this.options.sampleSize;
        var m_dFrequencyStability = this.options.frequencyStability;
        var m_dPeak1X = m_iRowLength / 8.0;
        var m_dPeak2X = m_iRowLength / 2.0;
        var aNewData = new Array(m_iRowLength);
        for (var i = 0; i < m_iRowLength; i++)
            aNewData[i] = m_dInitialValue;
        var dHalf = m_iRowLength / 2.0;
        m_dPeak1X += (Math.random() - 0.5) * m_dVariation / m_dFrequencyStability / 100.0 * m_iRowLength / 2.0;
        m_dPeak2X += (Math.random() - 0.5) * m_dVariation / m_dFrequencyStability / 100.0 * m_iRowLength;
        if (m_dPeak1X < 0)
            m_dPeak1X = 0;
        if (m_dPeak1X > m_iRowLength)
            m_dPeak1X = m_iRowLength;
        if (m_dPeak2X < 0)
            m_dPeak2X = 0;
        if (m_dPeak2X > m_iRowLength)
            m_dPeak2X = m_iRowLength;
        var dNewValue1;
        var dNewValue2;
        var dX1;
        var dX2;
        var dPeakY1 = m_dMax / 3.0 * 2.0;
        var dPeakY2 = m_dMax / 2.0;
        var dNarrowFactor1 = this.options.narrowFactor1;
        var dNarrowFactor2 = this.options.narrowFactor2;
        var dA1 = dPeakY1 / (dHalf * dHalf) * dNarrowFactor1;
        var dA2 = dPeakY2 / (dHalf * dHalf) * dNarrowFactor2;
        var dSum12;
        for (var i = 0; i < m_iRowLength; i++) {
            dX1 = 0.8 * i - m_dPeak1X;
            dX2 = 0.8 * i - m_dPeak2X;
            dNewValue1 = dPeakY1 - dX1 * dX1 * dA1;
            if (dNewValue1 < m_dMin)
                dNewValue1 = m_dMin;
            if (dNewValue1 > m_dMax)
                dNewValue1 = m_dMax;
            dNewValue2 = dPeakY2 - dX2 * dX2 * dA2;
            if (dNewValue2 < m_dMin)
                dNewValue2 = m_dMin;
            if (dNewValue2 > m_dMax)
                dNewValue2 = m_dMax;
            dSum12 = dNewValue1 + dNewValue2;
            dSum12 = dSum12 + dSum12 * (Math.random() - 0.5) * m_dVariation / 10.0;
            aNewData[i] = (aNewData[i] + dSum12) / 2.0;
            if (aNewData[i] < m_dMin)
                aNewData[i] = m_dMin;
            if (aNewData[i] > m_dMax)
                aNewData[i] = m_dMax;
            aNewData[i] = aNewData[i] * 0.02;
        }
        return aNewData;
    };
    SpectrumDataGenerator.prototype.infiniteReset = function (dataToReset, data) {
        return dataToReset.slice();
    };
    return SpectrumDataGenerator;
}(DataGenerator));

var defaultOptions$1 = {
    rows: 10,
    columns: 10,
    rowPositionsNormalized: [0.2, 0.5, 0.7],
    columnPositionsNormalized: [0.6, 0.5, 0.3],
    amplitudes: [15, 50, 3],
    offsetLevel: 47,
    volatility: 25
};
function createWaterDropDataGenerator() {
    return new WaterDropDataGenerator(defaultOptions$1);
}
var WaterDropDataGenerator = (function () {
    function WaterDropDataGenerator(args) {
        var opts = {
            rows: args.rows !== undefined ? args.rows : defaultOptions$1.rows,
            columns: args.columns !== undefined ? args.columns : defaultOptions$1.columns,
            rowPositionsNormalized: args.rowPositionsNormalized !== undefined ? args.rowPositionsNormalized : defaultOptions$1.rowPositionsNormalized,
            columnPositionsNormalized: args.columnPositionsNormalized !== undefined ? args.columnPositionsNormalized : defaultOptions$1.columnPositionsNormalized,
            amplitudes: args.amplitudes !== undefined ? args.amplitudes : defaultOptions$1.amplitudes,
            offsetLevel: args.offsetLevel !== undefined ? args.offsetLevel : defaultOptions$1.offsetLevel,
            volatility: args.volatility !== undefined ? args.volatility : defaultOptions$1.volatility
        };
        this.options = Object.freeze(opts);
    }
    WaterDropDataGenerator.prototype.setRows = function (rows) {
        return new WaterDropDataGenerator(__assign(__assign({}, this.options), { rows: rows }));
    };
    WaterDropDataGenerator.prototype.setColumns = function (columns) {
        return new WaterDropDataGenerator(__assign(__assign({}, this.options), { columns: columns }));
    };
    WaterDropDataGenerator.prototype.setWaterDrops = function (waterDrops) {
        var rowPositionsNormalized = waterDrops.map(function (waterDrop) { return waterDrop.rowNormalized; });
        var columnPositionsNormalized = waterDrops.map(function (waterDrop) { return waterDrop.columnNormalized; });
        var amplitudes = waterDrops.map(function (waterDrop) { return waterDrop.amplitude; });
        return new WaterDropDataGenerator(__assign(__assign({}, this.options), { rowPositionsNormalized: rowPositionsNormalized, columnPositionsNormalized: columnPositionsNormalized, amplitudes: amplitudes }));
    };
    WaterDropDataGenerator.prototype.setOffsetLevel = function (offsetLevel) {
        return new WaterDropDataGenerator(__assign(__assign({}, this.options), { offsetLevel: offsetLevel }));
    };
    WaterDropDataGenerator.prototype.setVolatility = function (volatility) {
        return new WaterDropDataGenerator(__assign(__assign({}, this.options), { volatility: volatility }));
    };
    WaterDropDataGenerator.prototype.generate = function () {
        var _this = this;
        return new Promise(function (resolve) { return __awaiter(_this, void 0, void 0, function () {
            function CalculateWavesAtPoint(x, z) {
                var resultValue = 0;
                var iOscillatorCount = oscillators.length;
                for (var i = 0; i < iOscillatorCount; i++) {
                    var oscillator = oscillators[i];
                    var distX = x - oscillator.centerX;
                    var distZ = z - oscillator.centerZ;
                    var dist = Math.sqrt(distX * distX + distZ * distZ);
                    resultValue += oscillator.gain * oscillator.amplitude * Math.cos(dist * volatility) * Math.exp(-dist * 3.0);
                }
                return resultValue;
            }
            var sizeX, sizeZ, xPositionsNormalized, zPositionsNormalized, amplitudes, offsetLevel, volatility, iOscCount, oscillators, iOsc, result, dTotalX, dTotalZ, stepX, stepZ, lastTimeout, iDataPoint, row, z, col, x;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sizeX = this.options.rows;
                        sizeZ = this.options.columns;
                        xPositionsNormalized = this.options.rowPositionsNormalized;
                        zPositionsNormalized = this.options.columnPositionsNormalized;
                        amplitudes = this.options.amplitudes;
                        offsetLevel = this.options.offsetLevel;
                        volatility = this.options.volatility;
                        iOscCount = amplitudes.length;
                        oscillators = Array(iOscCount);
                        for (iOsc = 0; iOsc < iOscCount; iOsc++) {
                            oscillators[iOsc] = {
                                amplitude: amplitudes[iOsc],
                                centerX: xPositionsNormalized[iOsc],
                                centerZ: zPositionsNormalized[iOsc],
                                gain: 1,
                                offsetY: 0
                            };
                        }
                        result = Array.from(Array(sizeX)).map(function () { return Array(sizeZ); });
                        dTotalX = 1;
                        dTotalZ = 1;
                        stepX = (dTotalX / sizeX);
                        stepZ = (dTotalZ / sizeZ);
                        lastTimeout = Date.now();
                        iDataPoint = 0;
                        row = 0, z = 0;
                        _a.label = 1;
                    case 1:
                        if (!(row < sizeZ)) return [3, 6];
                        col = 0, x = 0;
                        _a.label = 2;
                    case 2:
                        if (!(col < sizeX)) return [3, 5];
                        result[col][row] = CalculateWavesAtPoint(x, z) + offsetLevel;
                        iDataPoint++;
                        if (!(iDataPoint > 0 && iDataPoint % 1000 === 0)) return [3, 4];
                        if (!(Date.now() - lastTimeout >= 15)) return [3, 4];
                        return [4, new Promise(function (clbk) { return setTimeout(clbk, 0); })];
                    case 3:
                        _a.sent();
                        lastTimeout = Date.now();
                        _a.label = 4;
                    case 4:
                        col++, x += stepX;
                        return [3, 2];
                    case 5:
                        row++, z += stepZ;
                        return [3, 1];
                    case 6:
                        resolve(result);
                        return [2];
                }
            });
        }); });
    };
    return WaterDropDataGenerator;
}());

export { DataGenerator, DataHost, Stream, createDeltaFunctionGenerator, createOHLCGenerator, createParametricFunctionGenerator, createProgressiveFunctionGenerator, createProgressiveRandomGenerator, createProgressiveTraceGenerator, createSampledDataGenerator, createSpectrumDataGenerator, createTraceGenerator, createWaterDropDataGenerator, createWhiteNoiseGenerator };
//# sourceMappingURL=xydata.es.js.map
